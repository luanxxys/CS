Clipped from: http://blog.csdn.net/will130/article/details/51472716?locationNum=3&fps=1 
版权声明：本文为博主原创文章，未经博主允许不得转载。 
一、进程管理 
1、进程与线程有什么区别 
1. 定义：  
1）进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，它是系统进行资源分配和调度的一个独立单位。 
例如，用户运行自己的程序，系统就创建一个进程，并为它分配资源，包括各种表格、内存空间、磁盘空间、I/O 设备等，然后，该进程被放入到进程的就绪队列，进程调度程序选中它，为它分配 CPU 及其它相关资源，该进程就被运行起来。 
2）线程是进程的一个实体，是 CPU 调度和分派的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 
3）进程的引入大大地提高了资源的利用率和系统的吞吐量，而引入线程的目的是为了减少程序并发所付出的系统开销。进程是资源分配的单位，而线程是系统调度的单位。 
2. 为什么要引入线程（线程优点）：  
1）易于调度。  
2）提高并发性。可以启动多个线程执行同程序的不同部分，方便有效地实现并发。  
3）开销小。创建和切换线程比进程要快，开销也更少；共享进程的数据和代码，从而比进程需要通过消息才能通信来得更加简单。  
4）有利于发挥多处理器的功能。通过创建多线程，每个线程都在一个处理器上运行，从而实现应用程序的并行，使每个处理器都得到充分运行。 
3. 进程与线程区别：  
1）一个线程只能属于一个进程；一个进程至少拥有一个线程。 
2）属于一个进程的所有线程共享该线程的所有资源，包括打开的文件、创建的 Socket 等。不同的进程互相独立。 
3）线程又称为轻量级进程。进程有进程控制块，线程也有线程控制块。但线程控制块比进程控制块小得多。线程间切换代价小，进程间切换代价大。 
4）进程是程序的一次执行，线程可以理解为程序中一段程序片段的执行。 
5）每个进程拥有独立的内存空间，而线程共享其所属进程的内存空间。 
6）线程的划分尺度小于进程，使得多线程程序的并发性高。 
7）线程执行过程中很容易协作同步，而进程需要通过消息通信进行同步。 
4. 进程与程序区别：  
1）程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。而进程是一个动态的概念。  
2）程序可以作为一种软件资料长期存在，而进程是有一定生命期的。程序是永久的，进程是暂时的。  
3）进程更能真实地描述并发，而程序不能；  
4）进程由 PCB、程序段、数据段三部分组成;  
5）进程具有创建其他进程的功能，而程序没有。  
6）同一程序同时运行于若干个数据集合上，它将属于若干不同的进程，即同一程序可以对应多个进程。  
7）在传统的操作系统中，程序并不能独立运行，作为资源分配和独立运行的基本单元都是进程。 
5. 进程和线程优缺点：  
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在 SMP 机器上运行，而进程则可以跨机器迁移。 
2、线程同步有哪些机制？ 
现在流行的进程线程同步互斥的控制机制，其实是由最原始、最基本的 4 种方法：临界区、互斥量、信号量和事件来实现的。 
1）临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 
2）互斥量：为协调对一个共享资源的单独访问而设计，只有拥有互斥量的线程才有权去访问系统的公共资源，因为互斥量只有一个，所以能够保证资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。 
3）信号量：为控制一个具有有限数量的用户资源而设计。它允许多个线程在同一个时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。 
4）事件：用来通知线程有一些事件已经发生，从而启动后继任务开始。 
3、内核线程和用户线程的区别 
根据操作系统内核是否对线程可感知，可以把线程分为内核线程和用户线程。 
1. 定义：  
1）内核线程：操作系统内核支持的多线程。建立和销毁都是由操作系统负责、通过系统调用完成的，操作系统在调度时，参考各进程内的线程运行情况作出调度决定。如果一个进程中没有就绪态的线程，那么这个进程也不会被调度占用 CPU。 
2）用户线程：不需要内核支持而在用户程序中实现的线程。其不依赖于操作系统核心，用户进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。 
用户线程不需要用户态 / 核心态切换，速度快，操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少。为了在操作系统中加入线程支持，采用了在用户空间增加运行库来实现线程，这些运行库被称为 “线程包”，用户线程不能被操作系统所感知。 
2. 引入用户线程的优势：  
1）可以在不支持线程的操作系统中实现。  
2）创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。  
3）允许每个进程定制自己的调度算法，线程管理比较灵活。  
4）线程能够利用的表空间和堆栈空间比内核级线程多。 
3. 用户线程的缺点：  
1）同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。  
2）页面失效也会导致整个进程都会被挂起。  
内核线程的优缺点刚好跟用户线程相反。实际上，操作系统可以使用混合的方式来实现线程。 
二、内存管理 
1、内存管理有哪几种方式 
常见的内存管理方式有块式管理、页式管理、段式管理、段页式管理。最常用的是段页式管理。 
1）块式管理：把主存分为一大块一大块的，当所需的程序片段不在主存时，就分配一块主存空间，把程序片段载入主存，就算所需的程序片段只有几个字节也只能把这一块分配给它。会造成很大的浪费，平均浪费了 50% 的内存空间，但易于管理。 
2）页式管理：把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，显然这种方法的空间利用率要比块式管理高很多。 
3）段式管理：把主存分为一段一段的，每一段的空间又要比一页一页的小很多，空间利用率比页式管理高很多。但缺点是一个程序片段可能会分为几十段，很多时间就会被浪费在计算每一段的物理地址上。 
4）段页式管理：结合了段式管理和页式管理的优点。把主存先分成若干段，每个段又分为若干页。段页式管理每取一次数据，要访问 3 次内存。 
2、分段和分页的区别是什么？ 
1）页是信息的物理单位，分页是为了实现离散分配方式，以消减内存的外零头，提高内存的利用率；或者说分页仅仅是由于系统管理需要，而不是用户的需要。 
2）段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好的满足用户的需要。 
3）页的大小固定且由系统确定，段的长度却不固定，决定于用户所编写的程序。分页的作业地址空间是唯一的，即单一的线性空间，表示一地址；分段的作业地址空间是二维的，程序员在标识一个地址时，既需要给出段名，又需要给出段内地址。 
3、什么是虚拟内存？ 
虚拟内存简称虚存，是计算机系统内存管理的一种技术。它是相对物理地址而言的，可以理解为 “假的 “内存。 
它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），允许程序员编写并运行比实际系统拥有的内存大得多的程序，这使得许多大型软件项目能够在具有有限内存资源的系统上实现。而实际上，它通常被分割成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。 
虚存比实存有以下好处：  
1）扩大地址空间。无论段式虚存、页式虚存，或是段页式虚存，寻址空间都比实存大。  
2）内存保护。每个进程运行在各自虚存地址空间，互不干扰。可对特定内存地址提供写保护。  
3）公平分配内存。采用虚存后，每个进程都相当于有同样大小的虚存空间。  
4）当进程需要通信时，可采用虚存共享的方式实现 
虚存的代价：  
1）虚存的管理需要建立很多数据结构，占用额外内存。  
2）虚拟地址到物理地址的转换，增加了指令执行时间。  
3）页式的换入换出需要磁盘 I/O，耗费时间。  
4）如果一页中只有部分数据，浪费内存。 
4、什么是内存碎片？什么是内碎片？什么是外碎片？ 
1）内存碎片是由于多次进行内存分配造成的。当进行内存分配时，内存格式一般为：（用户使用段）（空白段）（用户使用段），当空白段很小的时候可能不能提供给用户足够多的空间，这样会产生很多的间隙造成使用效率的下降，这些很小的空隙叫碎片。 
2）内碎片：分配给程序的存储空间没用完，该程序不使用且其他程序也没法使用的空间。内碎片是处于区域内部或页面内部的存储块，占有它的进程并不使用，但系统也无法使用，直到释放。 
3）外碎片：由于空间太小，小到无法给任何程序分配（不属于任何进程）的存储空间。 
5、虚拟地址、逻辑地址、线性地址、物理地址有什么区别？ 
1）虚拟地址：由程序产生的有段选择符和段内偏移地址组成的地址。 
2）逻辑地址：由程序产生的段内偏移地址。有时直接把逻辑地址当成虚拟地址，两者并没有明确的界限。 
3）线性地址：指虚拟地址到物理地址变换之间的中间层，是处理器可寻址的内存空间（称为线性地址空间）中的地址。 
4）物理地址：是指现在 CPU 外部地址总线上寻址物理内存的地址信号，是地址变换的最终结果。 
6、Cache 替换算法有哪些？ 
CPU 处理快，但容量小；内存容量大，但转交给 CPU 处理的速度慢。cache 是 CPU 和内存之间的一个折中，可实现数据先从内存调入 cache，CPU 再从 cache 读取。 
由于主存中的块比 cache 中的块多，当要从主存中调入一个块到 cache 中时，会出现该块所映射的 cache 中的块全部占用，此时，需要腾出其中的某一块，以接纳新调入的块，这就是替换。 
Cache 替换算法有随机算法、FIFO 算法、近期最少使用算法（Least Recently Used，LRU 算法）、LFU 算法（近期最少访问算法）、OPT 算法（最优替换算法）  
1）随机算法：用随机数发生器产生一个要替换的块号，简单且易于实现。但命中率较低。  
2）FIFO 算法：将最先进入的 cache 块替换出去。易于实现，开销小。缺点是可能会把一些经常使用的程序块替换掉，而且不能提高命中率。  
3）最近最少使用算法（LRU）：淘汰最长时间未被使用的页面。比 FIFO 要好一些。要随时记录系统中各块的使用情况，实现相对复杂，系统开销较大  
4）最优替换算法（OPT）：使用该算法时必须先执行一次程序，统计 cache 的替换情况。有了先验信息，在第二次执行该程序时便可以用最有效的方式来替换，以达到最优的目的。这只是一种理想化的算法，经常把它作为评价其他算法好坏的标准。  
5）最近最不常用算法（LFU）：淘汰一定时期内访问次数最少的页面。LRU 的淘汰规则是基于访问时间，而 LFU 是基于访问次数。 
三、用户编程接口 
1、库函数调用与系统调用有什么不同？ 
库函数调用是语言或应用程序的一部分，是高层的，完全运行在用户空间，为程序员提供调用真正的在幕后完成实际事务的系统调用接口； 
系统函数是内核提供给应用程序的接口，属于系统的一部分。函数库调用是语言或应用程序的一部分，而系统调用是操作系统的一部分。 
2、静态链接与动态链接有什么区别？ 
1）静态链接：把要调用的函数或者过程直接链接到可执行文件，成为可执行文件的一部分。换句话说，函数和过程的代码就在程序的 exe 文件中，该文件包含了运行时所需要的全部代码。静态链接的缺点就是当多个程序都调用相同函数时，内存中就会出现这个函数的多个拷贝，造成内存的浪费。 
2）动态链接是相对静态链接而言的，动态链接所调用的函数并没有被复制到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息。仅当应用程序被装入内存开始运行时，在操作系统的管理下，才在应用程序与相应的动态链接库（dynamic link library ，dll）之间建立链接关系。 
3）静态链接的执行程序能在其他同类操作系统机器上直接运行，而动态链接则不可以，除非把 EXE 文件所需的 DLL 文件一起复制过去，或者对方机器上也有相同的 DLL 文件，否则不能正常运行。 
3、静态链接库与动态链接库有什么区别？ 
1）静态链接库就是使用. lib 文件，库中的代码最后需要链接到可执行文件中去，所以静态链接的可执行文件一般比较大一些。 
2）动态链接库是一个包含可由多个程序同时使用的代码和数据的库，它包含函数和数据的模块的集合。程序文件在运行时才会加载这些模块。 
3）相同点：它们都实现了代码的共享。 
4）不同点：静态链接库 lib 中的代码被包含在调用的 exe 文件中，该 lib 中不能再包含其他动态链接库或者静态链接库了。而动态链接库 dll 可以被调用的 exe 动态的” 引用 “和 “卸载”，该 dll 中可以包含其他动态链接库或者静态链接库。 
4、用户态和核心态有什么区别？ 
用户态与核心态是操作系统的两种运行级别，它用于区分不同程序的不同权利。 
核心态就是拥有资源多的状态，或者说访问资源多的状态，也称为特权态，访问资源不受任何限制。 
用户态就是非特权态，该状态下访问资源就会受到限制。 
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0 级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3 级）用户代码中运行。 
核心态下 CPU 可执行任何指令，用户态下 CPU 只能执行非特权指令。核心态可随意进入用户态，而用户态切换到核心态只有在系统调用和中断两种情况下发生。 
核心态和用户态各有优势：运行在核心态的程序可以访问更多资源，但可靠性、安全性要求高，维护管理都较复杂；用户态程序访问资源受限，但可靠性、安全性要求低，编写维护较简单。 
5、用户栈和内核栈有什么区别？ 
内核栈是系统运行在内核态的时候使用的栈，用户栈是系统运行在用户态时候使用的栈。 
当进程由于中断或系统调用而进入内核态时，进程所使用的堆栈也要从用户栈转到内核栈。系统会把一些用户态的数据信息保存到内核栈中，当返回到用户态时，取出内核栈中的信息恢复出来，返回到程序原来执行的地方。这就实现了内核栈和用户栈的互转。 
用户栈就是进程在用户空间时创建的栈，比如一般的函数调用，将会用到用户栈。用户栈是属于用户进程空间的一块区域，用户保存用户进程子程序间的相互调用的参数、返回值等。 
内核栈是属于操作系统空间的一块固定区域，可以用于保存中断现场、保存操作系统子程序间相互调用的参数、返回值等。 
