Clipped from: http://blog.csdn.net/tzy3013218117/article/details/51568804?locationNum=13&fps=1 
版权声明：本文为博主原创文章，未经博主允许不得转载。 
操作系统常见面试题及答案 
1 ．  什么是进程（Process ）和线程（Thread ）？有何区别？ 
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行 
资源分配和调度的一个独立单位。线程是进程的一个实体，是 CPU 调度和分派的基本单位， 
它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在 
运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其 
他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程；同一个进程中 
的多个线程之间可以并发执行。 
进程与应用程序的区别在于应用程序作为一个静态文件存储在计算机系统的硬盘等存 
储空间中，而进程则是处于动态条件下由操作系统维护的系统资源管理实体。 
2 ． Windows  下的内存是如何管理的？ 
Windows 提供了 3 种方法来进行内存管理：虚拟内存，最适合用来管理大型对象或者 
结构数组；内存映射文件，最适合用来管理大型数据流（通常来自文件）以及在单个计算机 
上运行多个进程之间共享数据；内存堆栈，最适合用来管理大量的小对象。 
Window 操纵内存可以分两个层面：物理内存和虚拟内存。 
其中物理内存由系统管理，不允许应用程序直接访问，应用程序可见的只有一个 2G 地 
址空间，而内存分配是通过堆进行的，对于每个进程都有自己的默认堆，当一个堆创建后， 
就通过虚拟内存操作保留了相应大小的地址块（不占有实际的内存，系统消耗很小），当在 
堆上分配一块内存时，系统在堆的地址表里找到一个空闲块（如果找不到，且堆创建属性是 
可扩充的，则扩充堆大小）为这个空闲块所包含的所有内存页提交物理对象（物理内存上或 
硬盘上的交换文件上）。这时可以就访问这部分地址了。提交时，系统将对所有进程的内存 
统一调配，如果物理内存不够，系统试图把一部分进程暂时不访问的页放入交换文件，以腾 
出部分物理内存。释放内存时，只在堆中将所在的页解除提交（相应的物理对象被解除）， 
继续保留地址空间。 
如果要知道某个地址是否被占用 / 可不可以访问，只要查询此地址的虚拟内存状 
VirtualQuery），如果是提交，则可以访问。如果仅仅保留，或没保留，则产生一个软件异常。 
此外有些内存页可以设置各种属性。如果是只读，向内写也会产生软件异常。 
3 ． Windows  消息调度机制是? 
A.  指令队列；B. 指令堆栈；C. 消息队列；D. 消息堆栈 
答案：C 
处理消息队列的顺序。首先 windows 绝对不是按队列先进先出的次序来处理的，而是有 
一定优先级的。优先级通过消息队列的状态标志来实现的。首先最高优先级的是别的线程发 
过来的消息 (通过 sendmessage), 其次是处理登记消息队列消息，再次处理 QS_QUIT 标志, 
再处理虚拟输入队列，再处理 wm_paint 最后是 wm_timer 
4 ．  描述 实时系统的基本特性 
在特定时间内完成特定的任务，实时性与可靠性。 
所谓 “实时操作系统”，实际上是指操作系统工作时，其各种资源可以根据需要随时进 
行动态分配。由于各种资源可以进行动态分配，因此其处理事务的能力较强、速度较快。 
5 ．  中断和轮询的特点。 
对 I/O 设备的程序轮询的方式，是早期的计算机系统对 I/O 设备的一种管理方式。它定 
时对各种设备轮流询问一遍有无处理要求。轮流询问之后，有要求的，则加以处理。在处理 
I/O 设备的要求之后，处理机返回继续工作。尽管轮询需要时间，但轮询要比 I/O 设备的速 
度要快得多，所以一般不会发生不能及时处理的问题。当然，再快的处理机，能处理的输入 
输出设备的数量也是有一定限度的。而且，程序轮询毕竟占据了 CPU 相当一部分处理时间， 
因此程序轮询是一种效率较低的方式，在现代计算机系统中已很少应用。 
程序中断通常简称中断，是指 CPU 在正常运行程序的过程中，由于预选安排或发生了 
各种随机的内部或外部事件，使 CPU 中断正在运行的程序，而转到为响应的服务程序去处 
理。 
轮询——效率低，等待时间很长，CPU 利用率不高 
中断——容易遗漏一些问题，CPU 利用率高 
6 ．  什么是临界区？如何解决冲突 ？ 
每个进程中访问临界资源的那段程序称为临界区，每次只准许一个进程进入临界区，进 
入后不允许其他进程进入。 
① 如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入。 
② 任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则 
其它所有试图进入临界区的进程必须等待。 
③ 进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区。 
④ 如果进程不能进入自己的临界区，则应让出 CPU，避免进程出现 “忙等” 现象。 
7 ．  说说分段和分页 
页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的 
利用率；或者说，分页仅仅是由于系统管理的需要，而不是用户的需要。 
段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好的 
满足用户的需要。页的大小固定且由系统确定，把逻辑地址划分为页号和页内地址两部分， 
是由机器硬件实现的，因而一个系统只能有一种大小的页面。 段的长度却不固定，决定于 
用户所编写的程序，通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分。 
分页的作业地址空间是维一的，即单一的线性空间，程序员只须利用一个记忆符，即可 
表示一地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又 
需给出段内地址 
8 ．  进程通信有哪些方式？ 
管道通信、消息通信、内存共享 
9 ．  说出你所知道的保持进程同步的方法? 
进程间同步的主要方法有内存屏障，互斥锁，信号量和锁，管程，消息，管道。 
10 ．  Linux  中常用到的命令 
显示文件目录命令 ls 
改变当前目录命令 cd 如 cd / /home 
建立子目录 mkdir mkdir xiong 
删除子目录命令 rmdir 如 rmdir ／mnt／cdrom 
删除文件命令 RM 如 rm ／ucdos.bat 
文件复制命令 cp 如 cp ／ucdos／＊ ／fox 
获取帮助信息命令 man 如 man ls 
显示文件的内容 less 如 less mwm.lx 
重定向与管道 type 如 type readme>>direct，将文件 readme 的内容追加到文 direct 中 
11 ．  Linux  文件属性有哪些？（共十位） 
-rw-r--r-l 
那个是权限符号，总共是 - --- --- --- 这几个位 
第一个短横处是文件类型识别符：- 表示普通文件；c 表示字符设备（character）；b 表示块 
设备（block）；d 表示目录（directory）；l 表示链接文件（link） 
后面第一个三个连续的短横是用户权限位（User），第二个三个连续短横是组权限位（Group）， 
第三个三个连续短横是其他权限位（Other）。每个权限位有三个权限，r（读权限），w（写 
权限），x（执行权限）。如果每个权限位都有权限存在，那么满权限的情况就是：-rwxrwxrwx； 
权限为空的情况就是 - --- --- ---。 
权限的设定可以用 chmod 命令，其格式位：chomod ugo+/-/=rwx filename/directory。例如： 
一个文件 aaa 具有完全空的权限 - --- --- ---。以下命令： 
chmod u+rw aaa （给用户权限位设置读写权限，其权限表示为：- rw- --- ---） 
chmod g+r aaa (给组设置权限为可读，其权限表示为：- --- r-- ---） 
chmod ugo+rw aaa （给用户，组，其它用户或组设置权限为读写，权限表示为：- rw- rw- rw-) 
如果 aaa 具有满权限 - rwx rwx rwx，以下命令为： 
chmod u-x aaa （去掉用户可执行权限，权限表示为：- rw- rwx rwx） 
如果要给 aaa 赋予制定权限 - rwx r-x r-x，命令为： 
chmod u=rwx,go=rx aaa 
12 ．  UNIX  显示文件夹中文件名的命令是什么？能使文件内容显示在屏幕的命令是什 
么 ？ 
ls cat 
type tail 
13 ．  makefile  文件的作用是什么 ？ 
一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile 
定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重 
新编译，甚至于进行更复杂的功能操作，因为 makefile 就像一个 Shell 脚本一样，其中也 
可以执行操作系统的命令。makefile 带来的好处就是——“自动化编译”，一旦写好，只需 
要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。make 是一个 
命令工具，是一个解释 makefile 中指令的命令工具，一般来说，大多数的 IDE 都有这个命 
令，比如：Delphi 的 make，Visual C++ 的 nmake，Linux 下 GNU 的 make。可见，makefile 
都成为了一种在工程方面的编译方法。 
14 ．  简术 ISO OSI  的物理层 Layer1 ，链路层 Layer2 ，网络层 Layer3  的任务 
网络层：资料传送的目的地寻址，再选择出传送资料的最佳路线； 
链路层：负责网络上资料封包如何传送的方式； 
物理层：在设备与传输媒介之间建立及终止连接。参与通讯过程使得资源可以在共享的 
多用户中有效分配，对信号进行调制或转换使得用户设备中的数字信号定义能与信道上实际 
传送的数字信号相匹配。 
15 ．  CPU  在上电后，进入操作系统的 main() 之前必须做什么 ？ 
加电后，会触发 CPU 的 reset 信号，导致 CPU 复位，然后 CPU 会跳到 (arm 下 0x00000000,x86 
下 0xfffffff0) 执行指令。主要是做 CPU 初始化，确定 CPU 的工作模式，mmu 初始化。建立页 
表段表，初始化中孤单控制器和中断向量表，初始化输入和输出，初始化 nandflash，把 OS 
的 TEXT 区加载到 sdram，然后跳转到 sdram 的 main() 
16 ．  什么是中断？中断时 CPU  做什么工作 ？ 
中断是指在计算机执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得 
CPU 暂时中断当前正在执行的程序而转去执行相应的事件处理程序。待处理完毕后又返回原 
来被中断处继续执行或调度新的进程执行的过程。 
17 ．  存储过程是什么？有什么用？有什么优点？ 
存储过程（Stored Procedure）是一组为了完成特定功能的 SQL 语句集，经编译后存 
储在数据库中。用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执 
行它。存储过程是 SQL 语句和可选控制流语句的预编译集合，以一个名称存储并作为一个 
单元处理。存储过程存储在数据库内，可由应用程序通过一个调用执行，而且允许用户声明 
变量、有条件执行以及其它强大的编程功能。存储过程在创建时即在服务器上进行编译，所 
以执行起来比单个 SQL 语句快。 
存储过程的优点：（1）存储过程只在创造时进行编译，以后每次执行存储过程都不需 
再重新编译，而一般 SQL 语句每执行一次就编译一次, 所以使用存储过程可提高数据库执行 
速度；（2）当对数据库进行复杂操作时 (如对多个表进行 Update, Insert, Query, Delete 时）， 
可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用；（3）存储过 
程可以重复使用, 可减少数据库开发人员的工作量；（4）安全性高, 可设定只有某此用户才 
具有对指定存储过程的使用权。 
存储过程的缺点：（1）如果更改范围大到需要对输入存储过程的参数进行更改，或者 
要更改由其返回的数据，则您仍需要更新程序集中的代码以添加参数、更新 GetValue() 调 
用，等等，这时候估计比较繁琐了。（2）可移植性差。由于存储过程将应用程序绑定到 SQL 
Server，因此使用存储过程封装业务逻辑将限制应用程序的可移植性。 
18 ．  你知道操作系统的内容分为几块吗？什么叫做虚拟内存？他和主存的关系如何？ 
内存管理属于操作系统的内容吗？ 
操作系统的主要组成部分：进程和线程的管理，存储管理，设备管理，文件管理。 
虚拟内存是一些系统页文件，存放在磁盘上，每个系统页文件大小也为 4K，物理内存也被 
分页，每个页大小也为 4K，这样虚拟页文件和物理内存页就可以对应，实际上虚拟内存就 
是用于物理内存的临时存放的磁盘空间。页文件就是内存页，物理内存中每页叫物理页，磁 
盘上的页文件叫虚拟页，物理页 + 虚拟页就是系统所以使用的页文件的总和。属于。 
19 ．  进程是一个比较重要的概念，那么进程有哪几种状态吗？ 
基本状态有 3 种, 即 ready（就绪）,running（运行）,wait（等待）. 
20 ．  OS  中如何实现物理地址到逻辑地址的转换? 
CPU 要利用其段式内存管理单元，先将逻辑地址转换成一个线程地址，再利用其页式内 
存管理单元，转换为最终物理地址。 
21 ．  堆和栈的区别？ 
栈区，由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似 
于数据结构中的栈。堆：一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 
回收 。注意它与数据结构中的堆是两回事，分配方式是类似于链表。可能用到的关键字如 
下：new、malloc、delete、free 等等。 
22 ．  线程是否具有相同的堆栈 ？dll  是否有独立的堆栈 ？ 
每个线程有自己的堆栈。 
DLL 中有没有独立的堆栈，这个问题不好回答，或者说这个问题本身是否有问题。因为 
DLL 中的代码是被某些线程所执行，只有线程拥有堆栈，如果 DLL 中的代码是 EXE 中的线程 
所调用，那么这个时候是不是说这个 DLL 没有自己独立的堆栈？如果 DLL 中的代码是由 DLL 
自己创建的线程所执行，那么是不是说 DLL 有独立的堆栈？ 
以上讲的是堆栈，如果对于堆来说，每个 DLL 有自己的堆，所以如果是从 DLL 中动态分 
配的内存，最好是从 DLL 中删除，如果你从 DLL 中分配内存，然后在 EXE 中，或者另外一个 
DLL 中删除，很有可能导致程序崩溃。 
23 ．  网络编程中设计并发服务器，使用 “多进程” 与 “ 多线程” ” ，请问有什么区别？ 
进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。 
线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他 
线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 
两者都可以提高程序的并发度，提高程序运行效率和响应时间。 
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进 
程正相反。同时，线程适合于在 SMP 机器上运行，而进程则可以跨机器迁移。 
24 ．  解释一下分页式管理. 
用户程序的地址空间被划分成若干固定大小的区域，称为 “页”，相应地，内存空间分 
成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了 
离散分配。 
25 ．  解释一下 P  操作与 V  操作 
P 就是请求资源，V 就是释放资源 
26 ．  什么是缓冲区溢出？有什么危害？其原因是什么？ 
缓冲区溢出是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量溢的数 
据覆盖在合法数据上, 
危害：在当前网络与分布式系统安全中，被广泛利用的 50% 以上都是缓冲区溢出，其中 
最著名的例子是 1988 年利用 fingerd 漏洞的蠕虫。而缓冲区溢出中，最为危险的是堆栈溢出， 
因为入侵者可以利用堆栈溢出，在函数返回时改变返回程序的地址，让其跳转到任意地址， 
带来的危害一种是程序崩溃导致拒绝服务，另外一种就是跳转并且执行一段恶意代码，比如 
得到 shell，然后为所欲为。通过往程序的缓冲区写超出其长度的内容，造成缓冲区的溢出， 
从而破坏程序的堆栈，使程序转而执行其它指令，以达到攻击的目的。 
造成缓冲区溢出的原因是程序中没有仔细检查用户输入的参数 
27 ．  什么是死锁？其条件是什么？怎样避免死锁？ 
死锁的概念：在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进 
程释放它们现在保持着的资源，否则就不能向前推进。此时，每个进程都占用了一定的资源 
但是又不能向前推进，称这一组进程产生了死锁。 通俗的讲，就是两个或多个进程无止境 
的等候着永远不会成立的条件的一种系统状态。 
死锁产生的原因主要是：（1）系统资源不足；（2）进程运行推进的顺序不合适；（3）资 
源分配不当。 
产生死锁的必要条件：（1）互斥（mutual exclusion），一个资源每次只能被一个进程使 
用；（2）占有且等待（hold and wait），一个进程因请求资源而阻塞时，对已获得的资源保持 
不放；（3）不可抢占（no preemption），进程已获得的资源，在未使用完之前，不能强行剥 
夺；（4）环形等待（circular wait），若干进程之间形成一种首尾相接的循环等待资源关系。 
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 
一不满足，就不会发生死锁。 
死锁的解除与预防：理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大 
可能地避免、预防和 解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个 
必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外， 也要 
防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。 
死锁的处理策略：鸵鸟策略、预防策略、避免策略、检测与解除死锁 
